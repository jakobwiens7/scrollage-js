{"version":3,"file":"scrollage.min.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACsC;AACqD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C,mBAAmB;AACnB,SAAS;AACT;AACA,qBAAqB,qBAAqB;AAC1C,mBAAmB;AACnB,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,iBAAiB,UAAU;AAC3B,eAAe,UAAU;AACzB;AACA,qBAAqB,UAAU;AAC/B,mBAAmB;AACnB,SAAS;AACT;AACA,qBAAqB,UAAU;AAC/B,mBAAmB;AACnB,SAAS;AACT;AACA,qBAAqB,UAAU;AAC/B,mBAAmB;AACnB,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,iBAAiB,YAAY;AAC7B,eAAe,YAAY;AAC3B;AACA,qBAAqB,YAAY;AACjC,mBAAmB;AACnB,SAAS;AACT;AACA,qBAAqB,YAAY;AACjC,mBAAmB;AACnB,SAAS;AACT;AACA,qBAAqB,YAAY;AACjC,mBAAmB;AACnB,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,iBAAiB,YAAY;AAC7B,eAAe,YAAY;AAC3B;AACA;AACA,KAAK;AACL;AACA,iBAAiB,YAAY;AAC7B,eAAe,YAAY;AAC3B;AACA,KAAK;AACL;AACA,iBAAiB,UAAU;AAC3B,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA,8CAA8C,yDAAc;AAC5D,0CAA0C,yDAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK,0BAA0B,KAAK;AAC3F;AACA,6CAA6C,KAAK;AAClD,sBAAsB,yDAAc,uBAAuB,KAAK;AAChE;AACA;AACA,yCAAyC,KAAK;AAC9C,sBAAsB,yDAAc,qBAAqB,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA,aAAa,eAAe;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA,+BAA+B,wDAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAW;AAC7B,mBAAmB,kDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA,2BAA2B,6DAAkB;AAC7C,yBAAyB,6DAAkB;AAC3C;AACA;AACA;AACA;AACA,mBAAmB,qDAAU;AAC7B,mBAAmB,qDAAU;AAC7B;AACA,wBAAwB,OAAO,MAAM,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAU,QAAQ;AAC3C;AACA;AACA;AACA,mDAAmD,qDAAU,yBAAyB;AACtF,mDAAmD,qDAAU,yBAAyB;AACtF,mDAAmD,qDAAU,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAU,YAAY;AAC/C;AACA;AACA;AACA,+CAA+C,oBAAoB;AACnE,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA,WAAW,qDAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA,uBAAuB,qDAAU,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA,mBAAmB,qDAAU,WAAW;AACxC;;;;;;;;;;;;;;;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;;;;;AC3E3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACO;AACP;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ,kDAAkD,qBAAqB;AAC1F,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,aAAa,kBAAkB;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS,GAAG,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA,MAAM;AACN,qDAAqD,QAAQ;AAC7D,mBAAmB;AACnB;AACA;;;;;;;;;;;ACvIA;;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA;AAC6G;AAChB;AACjB;AAC5E;AACA;AAC0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mDAAmD;AAC5D,SAAS,4BAA4B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,QAAQ,WAAW;AAClC;AACA,gBAAgB,SAAS;AACzB;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAU;AACf;AACA;AACA,uBAAuB;AACvB;AACA,mBAAmB;AACnB;AACA,qBAAqB,mEAAkB;AACvC;AACA;AACA;AACA,2BAA2B,qEAAoB;AAC/C;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,mDAAQ;AACX;AACA;AACA;AACA,GAAG,mDAAQ;AACX;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA,4CAA4C,mDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,WAAW;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAgB;AACtC;AACA;AACA,uCAAuC,qDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA,oBAAoB,qDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAc;AACzC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qDAAU;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA,eAAe,qDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qDAAU;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B;AACA,cAAc,QAAQ;AACtB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB;AACA;AACA,0BAA0B,yDAAc;AACxC,wBAAwB,yDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAkB;AAC9C,0BAA0B,6DAAkB;AAC5C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAkB;AAC9C,0BAA0B,6DAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,aAAa;AACzB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,KAAK,EAAE,EAMV;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA,MAAM,mDAAI;AACV;AACA;AACA;AACA;AACA,MAAM,qDAAM;AACZ;AACA;AACA;AACA;AACA,MAAM,oDAAK;AACX;AACA;AACA;AACA;AACA,MAAM,uDAAQ;AACd;AACA;AACA;AACA;AACA,MAAM,mDAAI;AACV;AACA;AACA;AACA,oBAAoB,mDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAQ;AAC/C,kDAAkD,mDAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","sources":["webpack://scrollagejs/../../../../\u0000#TEZMO.DEV/Libraries/ScrollageJS/scrollage-js/src/animation.js","webpack://scrollagejs/../../../../\u0000#TEZMO.DEV/Libraries/ScrollageJS/scrollage-js/src/breakpoints.js","webpack://scrollagejs/../../../../\u0000#TEZMO.DEV/Libraries/ScrollageJS/scrollage-js/src/easing.js","webpack://scrollagejs/../../../../\u0000#TEZMO.DEV/Libraries/ScrollageJS/scrollage-js/src/utils.js","webpack://scrollagejs/../../../../\u0000#TEZMO.DEV/Libraries/ScrollageJS/scrollage-js/src/scrollage.scss","webpack://scrollagejs/webpack/bootstrap","webpack://scrollagejs/webpack/runtime/define property getters","webpack://scrollagejs/webpack/runtime/hasOwnProperty shorthand","webpack://scrollagejs/webpack/runtime/make namespace object","webpack://scrollagejs/../../../../\u0000#TEZMO.DEV/Libraries/ScrollageJS/scrollage-js/src/index.js"],"sourcesContent":["// Dependencies\r\nimport EasingFuncs from './easing.js';\r\nimport { splitValueUnit, calculateUnitValue, roundValue, safeParseJSON } from './utils.js';\r\n\r\n\r\n// Animation default values\r\n// TO-DO: skew, box-shadow, text-shadow, color, bgColor/bgGradient?\r\nconst ANIMATION_DEFAULTS = {\r\n    move: {\r\n        x: {\r\n            start: { unit: '%', value: 0 },\r\n            end: { unit: '%', value: 0 }\r\n        },\r\n        y: {\r\n            start: { unit: '%', value: 0 },\r\n            end: { unit: '%', value: 0 }\r\n        },\r\n        easing: false,\r\n        responsive: null\r\n    },\r\n    rotate: {\r\n        start: { value: 0 },\r\n        end: { value: 0 },\r\n        x: {\r\n            start: { value: 0 },\r\n            end: { value: 0 }\r\n        },\r\n        y: {\r\n            start: { value: 0 },\r\n            end: { value: 0 }\r\n        },\r\n        z: {\r\n            start: { value: 0 },\r\n            end: { value: 0 }\r\n        },\r\n        easing: false,\r\n        responsive: null\r\n    },\r\n    scale: {\r\n        start: { value: 100 },\r\n        end: { value: 100 },\r\n        x: {\r\n            start: { value: 100 },\r\n            end: { value: 100 }\r\n        },\r\n        y: {\r\n            start: { value: 100 },\r\n            end: { value: 100 }\r\n        },\r\n        z: {\r\n            start: { value: 100 },\r\n            end: { value: 100 }\r\n        },\r\n        easing: false,\r\n        responsive: null\r\n    },\r\n    fade: {\r\n        start: { value: 100 },\r\n        end: { value: 100 },\r\n        easing: false,\r\n        responsive: null\r\n    },\r\n    saturate: {\r\n        start: { value: 100 },\r\n        end: { value: 100 },\t\r\n        responsive: null\r\n    },\r\n    blur: {\r\n        start: { value: 0 },\r\n        end: { value: 0 },\t\r\n        responsive: null\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Extracts and structures start and end values for animation properties.\r\n *\r\n * This function processes an object containing movement values (startX, endX, startY, endY, etc.)\r\n * and returns a structured format containing extracted values with proper defaults.\r\n *\r\n * @param {Object} obj - The object containing animation data.\r\n * @param {Object} defaultObj - The object containing default values for fallback.\r\n * \r\n * @returns {Object} - A structured object with extracted start and end values.\r\n */\r\nfunction extractStartEndData(obj, defaultObj) {\r\n    \r\n    // Normalize object keys: Convert all keys to lowercase\r\n    const normalizedObj = Object.keys(obj).reduce((acc, key) => {\r\n        acc[key.toLowerCase()] = obj[key];\r\n        return acc;\r\n    }, {});\r\n\r\n    // Process top-level 'start' or 'end' properties and return immediately\r\n    if ('start' in normalizedObj || 'end' in normalizedObj) {\r\n        return {\r\n            start: 'start' in normalizedObj ? splitValueUnit(normalizedObj.start) : defaultObj.start,\r\n            end: 'end' in normalizedObj ? splitValueUnit(normalizedObj.end) : defaultObj.end\r\n        };\r\n    }\r\n\r\n    // Process axis-based values (x, y, z)\r\n    const axes = ['x', 'y', 'z'];\r\n    const newObj = {}\r\n\r\n    for (const axis of axes) {\r\n        if (defaultObj[axis] && (normalizedObj[`start${axis}`] || normalizedObj[`end${axis}`])) {\r\n            newObj[axis] = {\r\n                start: normalizedObj[`start${axis}`]\r\n                    ? splitValueUnit(normalizedObj[`start${axis}`]) \r\n                    : defaultObj[axis].start,\r\n\r\n                end: normalizedObj[`end${axis}`]\r\n                    ? splitValueUnit(normalizedObj[`end${axis}`]) \r\n                    : defaultObj[axis].end\r\n            };\r\n        }\r\n    }\r\n    return newObj;\r\n}\r\n\r\n\r\n/**\r\n * Extracts animation data attributes from an element and returns a structured animation configuration.\r\n *\r\n * @param {HTMLElement} el - The element from which animation data attributes are extracted.\r\n * \r\n * @returns {Array<Object>} - An array of animation objects, each containing a specific animation type and its properties.\r\n */\r\nexport function getAnimationData(el) {\r\n    const animations = [];\r\n    const animationTypes = Object.keys(ANIMATION_DEFAULTS);\r\n\r\n    for (const type of animationTypes) {\r\n        const attrName = `data-scrollage-${type}`;\r\n        const data = el.getAttribute(attrName);\r\n\r\n        if (data) {\r\n            const parsedData = safeParseJSON(data, attrName);\r\n            const responsiveData = parsedData.responsive || {};\r\n\r\n            // Extract responsive animation settings\r\n            const responsiveConfig = Object.keys(responsiveData).reduce((acc, breakpoint) => {\r\n                acc[breakpoint] = extractStartEndData(responsiveData[breakpoint], ANIMATION_DEFAULTS[type]);\r\n                return acc;\r\n            }, {});\r\n\r\n            animations.push({\r\n                [type]: {\r\n                    ...extractStartEndData(parsedData, ANIMATION_DEFAULTS[type]),\r\n                    responsive: Object.keys(responsiveData).length ? responsiveConfig : undefined,\r\n                    easing: parsedData.easing || undefined\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    return animations;\r\n}\r\n\r\n\r\n/**\r\n * Calculates the interpolated animation progress between a start and end value.\r\n *\r\n * - If an easing function is provided, it applies the easing to the progress.\r\n * - Ensures progress is clamped between `0` and `1` to prevent unexpected results.\r\n * - Uses `EasingFuncs` to retrieve the easing function safely.\r\n *\r\n * @param {number} start - The starting value of the animation.\r\n * @param {number} end - The ending value of the animation.\r\n * @param {number} [progress=0] - The current progress (between 0 and 1).\r\n * @param {string|false} [easing=false] - The easing function name (case-insensitive) or `false` for linear animation.\r\n * \r\n * @returns {number} - The calculated interpolated value.\r\n */\r\nfunction getAnimationProgress(start, end, progress = 0, easing = false ) {\r\n\r\n    // Clamp progress between 0 and 1\r\n    progress = Math.max(0, Math.min(1, progress));\r\n\r\n    // Apply easing if provided and valid\r\n    if (easing && EasingFuncs[easing.toLowerCase()]) {\r\n        progress = EasingFuncs[easing.toLowerCase()](progress);\r\n    }\r\n\r\n    return start + (end - start) * progress;\r\n}\r\n\r\n\r\n/**\r\n * Calculates the transform `translate` values for an element.\r\n *\r\n * - Converts percentage-based movement values to pixel values relative to `rangeSize`.\r\n * - Uses `getAnimationProgress()` to interpolate movement based on scroll progress.\r\n *\r\n * @param {Object} animationData - The movement animation configuration.\r\n * @param {number} progress - The current animation progress (0 to 1).\r\n * @param {Object} rangeSize - The range dimensions used for percentage calculations.\r\n * @param {Object} elSize - The target element dimensions.\r\n * @param {Object} winSize - The window dimensions for vw/vh unit calculation.\r\n * \r\n * @returns {string} - The computed `translate` CSS transformation string.\r\n */\r\nexport function move(animationData, progress, rangeSize, elSize, winSize) {\r\n\r\n    const calculateMovement = (axis) => {\r\n        if (!animationData[axis]) return 0;\r\n\r\n        const { start, end } = animationData[axis];\r\n\r\n        const startValue = calculateUnitValue(start.unit, start.value, winSize, rangeSize[axis], elSize[axis]);\r\n        const endValue = calculateUnitValue(end.unit, end.value, winSize, rangeSize[axis], elSize[axis]);\r\n\r\n        return getAnimationProgress(startValue, endValue, progress, animationData.easing);\r\n    };\r\n\r\n    const valueX = roundValue(calculateMovement('x'));\r\n    const valueY = roundValue(calculateMovement('y'));\r\n\r\n    return `translate(${valueX}px, ${valueY}px)`;\r\n}\r\n\r\n\r\n/**\r\n * Calculates the transform `rotate` values for an element.\r\n *\r\n * - Supports independent rotation on the X, Y, and Z axes.\r\n * - Uses `getAnimationProgress()` to interpolate rotation values based on scroll progress.\r\n *\r\n * @param {Object} animationData - The rotation animation configuration.\r\n * @param {number} progress - The current animation progress (0 to 1).\r\n * \r\n * @returns {string} - The computed `transform` CSS property with rotations.\r\n */\r\nexport function rotate(animationData, progress) {\r\n    const calculateRotation = (axis) => {\r\n        if (!animationData[axis]) return null;\r\n        \r\n        return getAnimationProgress(\r\n            animationData[axis].start.value,\r\n            animationData[axis].end.value,\r\n            progress,\r\n            animationData.easing\r\n        );\r\n    };\r\n\r\n    // Prioritize 'start' and 'end' values, if defined\r\n    if (animationData.start && animationData.end) {\r\n        const value = getAnimationProgress(animationData.start.value, animationData.end.value, progress, animationData.easing);\r\n        return `rotate(${roundValue(value)}deg)`;\r\n    }\r\n\r\n    const rotations = [];\r\n    if (animationData.x) rotations.push(`rotateX(${roundValue(calculateRotation('x'))}deg)`);\r\n    if (animationData.y) rotations.push(`rotateY(${roundValue(calculateRotation('y'))}deg)`);\r\n    if (animationData.z) rotations.push(`rotateZ(${roundValue(calculateRotation('z'))}deg)`);\r\n\r\n    return rotations.join(' ');\r\n}\r\n\r\n\r\n/**\r\n * Calculates the CSS scale transform values for an element.\r\n *\r\n * - Supports independent scaling on the X, Y, and Z axes.\r\n * - Uses `getAnimationProgress()` to interpolate scale values based on scroll progress.\r\n * \r\n * @param {Object} animationData - The scale animation configuration.\r\n * @param {number} progress - The current animation progress (0 to 1).\r\n * \r\n * @returns {string} - The computed `transform` CSS property with scaling.\r\n */\r\nexport function scale(animationData, progress) {\r\n    const calculateScale = (axis) => {\r\n        if (!animationData[axis]) return null;\r\n        \r\n        return getAnimationProgress(\r\n            animationData[axis].start.value/100,\r\n            animationData[axis].end.value/100,\r\n            progress,\r\n            animationData.easing\r\n        );\r\n    };\r\n\r\n    // Prioritize 'start' and 'end' values, if defined\r\n    if (animationData.start && animationData.end) {\r\n        const value = getAnimationProgress(animationData.start.value/100, animationData.end.value/100, progress, animationData.easing);\r\n        return `scale(${ roundValue(value, 2) })`;\r\n    }\r\n\r\n    const scales = [];\r\n    if (animationData.x) scales.push(`scaleX(${calculateScale('x')})`);\r\n    if (animationData.y) scales.push(`scaleY(${calculateScale('y')})`);\r\n\r\n    return scales.join(' ');\r\n}\r\n\r\n\r\n/**\r\n * Calculates the CSS opacity value for a fade animation.\r\n *\r\n * - Uses `getAnimationProgress()` to interpolate opacity based on scroll progress.\r\n *\r\n * @param {Object} animationData - The fade animation configuration.\r\n * @param {number} progress - The current animation progress (0 to 1).\r\n * \r\n * @returns {string} - The computed `opacity` CSS property.\r\n */\r\nexport function fade(animationData, progress) {\r\n    const value = getAnimationProgress(animationData.start.value, animationData.end.value, progress, animationData.easing);\r\n    return roundValue(value / 100, 2);\r\n}\r\n\r\n\r\n/**\r\n * Calculates the CSS saturate filter value for a saturate animation.\r\n *\r\n * - Uses `getAnimationProgress()` to interpolate saturation based on scroll progress.\r\n *\r\n * @param {Object} animationData - The saturate animation configuration.\r\n * @param {number} progress - The current animation progress (0 to 1).\r\n * \r\n * @returns {string} - The computed `filter: saturate(%)` CSS property.\r\n */\r\nexport function saturate(animationData, progress) {\r\n    const value = getAnimationProgress(animationData.start.value, animationData.end.value, progress);\r\n    return `saturate(${roundValue(value, 0)}%)`;\r\n}\r\n\r\n\r\n/**\r\n * Calculates the CSS blur filter value for a blur animation.\r\n *\r\n * - Uses `getAnimationProgress()` to interpolate blur intensity based on scroll progress.\r\n *\r\n * @param {Object} animationData - The blur animation configuration.\r\n * @param {number} progress - The current animation progress (0 to 1).\r\n * \r\n * @returns {string} - The computed `filter: blur(px)` CSS property.\r\n */\r\nexport function blur(animationData, progress) {\r\n    const value = getAnimationProgress(animationData.start.value, animationData.end.value, progress);\r\n    return `blur(${roundValue(value, 0)}px)`;\r\n}\r\n","\r\n//export const DEFAULT_BREAKPOINTS = [781, 1024, 1366];\r\n\r\n\r\n/**\r\n * Determines the current breakpoint based on the window width and the defined breakpoints.\r\n * \r\n * @param {number[]} breakpoints - An array of breakpoints (e.g., `[600, 1024, 1366]`).\r\n * @param {number} width - The current window width.\r\n * \r\n * @returns {string} - The current breakpoint as a string: 'phone', 'tablet', 'laptop', or 'desktop'.\r\n */\r\nexport function getCurrentBreakpoint(width, breakpoints) {\r\n    if (width <= breakpoints[0]) return 'phone';\r\n    if (width <= breakpoints[1]) return 'tablet';\r\n    if (width <= breakpoints[2]) return 'laptop';\r\n    return 'desktop';\r\n}\r\n\r\n\r\n// Validate user defined custom breakpoints\r\nexport function isValidBreakpoints(breakpoints = []) {\r\n    if (breakpoints.length === 3 && Array.isArray(breakpoints)) {\r\n        let isAscending = true;\r\n        let isNumerical = true;\r\n        let lastVal;\r\n\r\n        breakpoints.forEach((i) => {\r\n            if (typeof i !== 'number') isNumerical = false;\r\n            if (lastVal !== null) {\r\n                if (i < lastVal) isAscending = false;\r\n            }\r\n            lastVal = i;\r\n        });\r\n        if (isAscending && isNumerical) return true;\r\n    }\r\n    // Revert to default if set incorrectly\r\n    console.warn(\"ScrollageJS: Breakpoints need to be an array of 3 values in ascending order.\");\r\n    return false;\r\n}\r\n\r\n","/**\r\n * Optimized Easing Functions by Michael \"Code Poet\" Pohoreski, aka Michaelangel007\r\n * https://github.com/Michaelangel007/easing\r\n */ \r\n\r\nconst EasingFuncs = {\r\n    insine: (p) => 1 - Math.cos(p * Math.PI * 0.5),\r\n    outsine: (p) => Math.sin(p * Math.PI * 0.5),\r\n    inoutsine: (p) => 0.5 * (1 - Math.cos(p * Math.PI)),\r\n    incubic: (p) => p * p * p,\r\n    outcubic: (p) => {\r\n        const m = p - 1;\r\n        return 1 + m * m * m;\r\n    },\r\n    inoutcubic: (p) => {\r\n        const m = p - 1, t = p * 2;\r\n        return t < 1 ? p * t * t : 1 + m * m * m * 4;\r\n    },\r\n    inquintic: (p) => p * p * p * p * p,\r\n    outquintic: (p) => {\r\n        const m = p - 1;\r\n        return 1 + m * m * m * m * m;\r\n    },\r\n    inoutquintic: (p) => {\r\n        const m = p - 1, t = p * 2;\r\n        return t < 1 ? p * t * t * t * t : 1 + m * m * m * m * m * 16;\r\n    },\r\n    incircle: (p) => 1 - Math.sqrt(1 - p * p),\r\n    outcircle: (p) => {\r\n        const m = p - 1;\r\n        return Math.sqrt(1 - m * m);\r\n    },\r\n    inoutcircle: (p) => {\r\n        const m = p - 1, t = p * 2;\r\n        return t < 1 ? (1 - Math.sqrt(1 - t * t)) * 0.5 : (Math.sqrt(1 - 4 * m * m) + 1) * 0.5;\r\n    },\r\n    inback: (p) => {\r\n        const k = 1.70158;\r\n        return p * p * (p * (k + 1) - k);\r\n    },\r\n    outback: (p) => {\r\n        const m = p - 1, k = 1.70158;\r\n        return 1 + m * m * (m * (k + 1) + k);\r\n    },\r\n    inoutback: (p) => {\r\n        const m = p - 1, t = p * 2, k = 1.70158 * 1.525;\r\n        return p < 0.5 ? p * t * (t * (k + 1) - k) : 1 + 2 * m * m * (2 * m * (k + 1) + k);\r\n    },\r\n    inbounce: (p) => 1 - EasingFuncs.OutBounce(1 - p),\r\n    outbounce: (p) => {\r\n        const r = 1 / 2.75, k0 = 7.5625, t = 0;\r\n        if (p < r) return k0 * p * p;\r\n        else if (p < 2 * r) return k0 * (t = p - 1.5 * r) * t + 0.75;\r\n        else if (p < 2.5 * r) return k0 * (t = p - 2.25 * r) * t + 0.9375;\r\n        else return k0 * (t = p - 2.625 * r) * t + 0.984375;\r\n    },\r\n    inoutbounce: (p) => {\r\n        const t = p * 2;\r\n        return t < 1\r\n            ? 0.5 - 0.5 * EasingFuncs.OutBounce(1 - t)\r\n            : 0.5 + 0.5 * EasingFuncs.OutBounce(t - 1);\r\n    },\r\n    inelastic: (p) => {\r\n        const m = p - 1;\r\n        return -Math.pow(2, 10 * m) * Math.sin((m * 40 - 3) * Math.PI / 6);\r\n    },\r\n    outelastic: (p) => 1 + Math.pow(2, -10 * p) * Math.sin((-p * 40 - 3) * Math.PI / 6),\r\n    inoutelastic: (p) => {\r\n        const s = 2 * p - 1, k = (80 * s - 9) * Math.PI / 18;\r\n        return s < 0\r\n            ? -0.5 * Math.pow(2, 10 * s) * Math.sin(k)\r\n            : 1 + 0.5 * Math.pow(2, -10 * s) * Math.sin(k);\r\n    },\r\n};\r\n\r\nexport default EasingFuncs;\r\n","/**\r\n * Checks if the browser supports passive event listeners.\r\n *\r\n * This function attempts to define a passive property in an event listener options object.\r\n * If successful, it confirms support for passive event listeners.\r\n *\r\n * @returns {boolean} - `true` if passive event listeners are supported, otherwise `false`.\r\n */\r\nexport function supportsPassiveEvents() {\r\n    let passiveSupported = false;\r\n    try {\r\n        const opts = Object.defineProperty({}, 'passive', {\r\n            get: function() {\r\n                passiveSupported = true;\r\n            }\r\n        });\r\n        window.addEventListener(\"testPassive\", null, opts);\r\n        window.removeEventListener(\"testPassive\", null, opts);\r\n    } catch (e) {}\r\n    return passiveSupported;\r\n}\r\n\r\n\r\n/**\r\n * Creates a debounced function that delays execution until after a set time.\r\n *\r\n * @param {Function} func - The function to debounce.\r\n * @param {number} [delay=100] - The delay time in milliseconds.\r\n * @returns {Function} - A debounced function.\r\n */\r\nexport function debounce(func, delay = 100) {\r\n    let timer;\r\n    return function(...args) {\r\n        if (timer) clearTimeout(timer);\r\n        timer = setTimeout(() => func.apply(this, args), delay);\r\n    };\r\n}\r\n\r\n\r\n/**\r\n * Splits a value (e.g., '50%' or '100px') into a numeric value and a unit.\r\n * \r\n * @param {string} str - The value to split (e.g., '50%' or '100px').\r\n * \r\n * @returns {Object} - An object containing the `value` (numeric value) and `unit` (unit).\r\n */\r\nexport function splitValueUnit(str) {\r\n    if (typeof str === 'number') return { value: str };\r\n    if (!str || typeof str !== 'string') return;\r\n\r\n    let strSplit = str.match(/^([-.\\d]+(?:\\.\\d+)?)(.*)$/);\r\n\r\n    return { \r\n        value: Number(strSplit[1].trim()), \r\n        unit: strSplit[2].trim()\r\n    };\r\n}\r\n\r\n/**\r\n * Converts a unit-based value (px, %, vw, vh) into an absolute pixel value.\r\n *\r\n * @param {string} unit - The unit type (e.g., \"px\", \"%\", \"vw\", \"vh\").\r\n * @param {number} value - The numeric value associated with the unit.\r\n * @param {number} totalSize - The total size of the container (used for percentage calculations).\r\n * @param {Object} winSizeObj - The viewport size with properties `{ x: width, y: height }`.\r\n * @param {number} [elSize=0] - The element's size (optional, used for percentage-based calculations).\r\n * \r\n * @returns {number} - The computed pixel value.\r\n */\r\nexport function calculateUnitValue(unit, value, winSizes, totalSize, elSize = 0) {\r\n    switch (unit) {\r\n        case 'vw': return (winSizes.x * value) / 100;\r\n        case 'vh': return (winSizes.y * value) / 100;\r\n        case 'px': return value;\r\n        default: return ((totalSize - elSize) * value) / 100; // Assume % by default\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Rounds a given number to a specified number of decimal places.\r\n *\r\n * @param {number} value - The number to be rounded.\r\n * @param {number} [decimals=1] - The number of decimal places to round to (default: 1).\r\n * @returns {number} - The rounded number.\r\n */\r\nexport function roundValue(value, decimals = 1) {\r\n    return Math.round(value * 10 ** decimals) / 10 ** decimals;\r\n}\r\n\r\n\r\n/**\r\n * Validates whether a given wrapper is a valid DOM element.\r\n *\r\n * - Allows both selector strings and direct element references.\r\n * - Checks if the element exists in the DOM.\r\n *\r\n * @param {string|HTMLElement|null} wrapper - The selector or element to validate.\r\n * @returns {HTMLElement|null} - The valid wrapper element or `null` if invalid.\r\n */\r\nexport function validateEl(el, context = 'element') {\r\n\r\n    // If it's already an element, return it directly\r\n    if (el instanceof HTMLElement) {\r\n        return el;\r\n    }\r\n\r\n    // If it's a string, try to select the element\r\n    if (typeof el === 'string') {\r\n        const selectedEl = document.querySelector(el);\r\n\r\n        if (selectedEl) return selectedEl;\r\n    }\r\n    \r\n    // Revert to default if not found\r\n    console.warn(`ScrollageJS: Your desired ${context} \"${el}\" is not a valid element or selector.`);\r\n    return null;\r\n}\r\n\r\n\r\n/**\r\n * Safely parses a JSON string and returns an object.\r\n * If parsing fails, logs a warning and returns an empty object.\r\n *\r\n * @param {string} jsonString - The JSON string to parse.\r\n * @param {string} context - The name of the attribute for error logging.\r\n * @returns {Object} - The parsed object or an empty object if parsing fails.\r\n */\r\nexport function safeParseJSON(jsonString, context = 'JSON data') {\r\n    try {\r\n        return JSON.parse(jsonString);\r\n    } catch (error) {\r\n        console.warn(`ScrollageJS: Invalid JSON in ${context}.`, error);\r\n        return {}; // Return empty object instead of undefined\r\n    }\r\n}","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Dependencies\r\nimport { supportsPassiveEvents, debounce, splitValueUnit, calculateUnitValue, validateEl } from './utils.js';\r\nimport { getAnimationData, move, rotate, scale, fade, blur, saturate } from './animation.js';\r\nimport { getCurrentBreakpoint, isValidBreakpoints } from './breakpoints.js';\r\n\r\n// \r\nimport './scrollage.scss';\r\n\r\n\r\n/**\r\n * ScrollageJS - A lightweight library for animating elements based on scroll position.\r\n *\r\n * @version 0.9.2\r\n * @author Jakob Wiens\r\n * @see {@link https://github.com/jakobwiens7/scrollage-js} Project Repository\r\n * @see {@link https://scrollage.de} Official Website\r\n *\r\n * @class Scrollage\r\n *\r\n * @license MIT\r\n * Copyright (c) 2025 Jakob Wiens\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\nclass Scrollage {\r\n\r\n\t// Current Scrollage version\r\n    static version = '0.9.2';\r\n\r\n\t// Determines if the browser supports passive event listeners.\r\n\tstatic supportsPassive = supportsPassiveEvents();\r\n\r\n\t// Default configuration settings for Scrollage.\r\n    static DEFAULT_OPTIONS = {\r\n        direction: 'vertical',\r\n        breakpoints: [781, 1024, 1366],\r\n        wrapper: null,\r\n        hasScrolledEnabled: true,\r\n        hasScrolledClass: 'has-scrolled',\r\n        hasScrolledOffset: 0,\r\n        triggers: [],\r\n        trackers: [],\r\n        // TO-DO: callback: function()\r\n    };\r\n\r\n\r\n\t/**\r\n     * Creates an instance of Scrollage.\r\n     *\r\n     * @param {string|HTMLElement} [el] - The selector or element to animate.\r\n     * @param {Object} [options={}] - Configuration options for customization.\r\n     *\r\n     * @throws {Warning} Logs a warning if initialized before the DOM is fully loaded.\r\n     */\r\n    constructor( el, options = {} ) {\r\n\t\t// Warn when DOM is not ready\r\n        if (document.readyState === 'loading') {\r\n            console.warn('ScrollageJS: DOM is not fully loaded. Ensure initialization happens after `DOMContentLoaded`.');\r\n        }\r\n\t\t\r\n\t\tthis.options = { ...Scrollage.DEFAULT_OPTIONS, ...options };\r\n\t\tthis.el = el || '.scrollage';\r\n\r\n\t\tthis.wrapper = null;\r\n\t\tthis.winSize = {};\r\n\t\tthis.currentBreakpoint = null;\r\n\t\tthis.breakpoints = [];\r\n\t\tthis.elems = [];\r\n\t\tthis.blocks = [];\r\n\t\tthis.triggers = [];\r\n\t\tthis.trackers =[];\r\n\r\n\t\tthis.init();\r\n    }\r\n\r\n\r\n\t/**\r\n\t * Initializes the scrollage system and caches all necessary element values.\r\n\t */\r\n\tinit() {\r\n\t\t// Validate elements and return early otherwise\r\n\t\tthis.elems = (typeof this.el === 'string') \r\n\t\t\t? document.querySelectorAll(this.el) \r\n\t\t\t: NodeList.prototype.isPrototypeOf(this.el) ? this.el : [this.el];\r\n\t\tif (!this.elems || !this.elems.length) return;\r\n\r\n\t\tthis.isVertical = this.options.direction !== 'horizontal';\r\n\r\n\t\t// Validate wrapper and set to default otherwise\r\n\t\tthis.wrapper = this.options.wrapper \r\n\t\t\t? validateEl(this.options.wrapper, 'wrapper') \r\n\t\t\t: document.documentElement || document.body;\r\n\r\n\t\tthis.wrapperSize = { x: this.wrapper.scrollWidth, y: this.wrapper.scrollHeight };\r\n\r\n\t\tthis.winSize = { x: window.innerWidth, y: window.innerHeight };\r\n\r\n\t\tthis.breakpoints = isValidBreakpoints(this.options.breakpoints) \r\n\t\t\t? this.options.breakpoints \r\n\t\t\t: Scrollage.DEFAULT_OPTIONS.breakpoints;\r\n\r\n\t\tthis.currentBreakpoint = getCurrentBreakpoint(this.winWidth, this.breakpoints);\r\n\r\n\t\t// Reset potential element styles\r\n\t\tif (this.blocks?.length) {\r\n\t\t\tfor (let i = 0; i < this.blocks.length; i++) {\r\n\t\t\t\tthis.elems[i].style.cssText = this.blocks[i].originalStyles || '';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Setup and cache\r\n\t\tthis.cacheBlocks();\r\n\t\tthis.cacheTriggers();\r\n\t\tthis.cacheTrackers();\r\n\r\n\t\t// Window resize & orientation change listeners\r\n\t\twindow.addEventListener(\r\n\t\t\t\"resize\", \r\n\t\t\tdebounce(this.init.bind(this))\r\n\t\t);\r\n\t\twindow.addEventListener(\r\n\t\t\t'orientationchange', \r\n\t\t\tdebounce(this.init.bind(this))\r\n\t\t);\r\n\r\n\t\t// Scroll & touch listeners\r\n\t\t(this.options.wrapper ? this.wrapper : window).addEventListener(\r\n\t\t\t'scroll', \r\n\t\t\tthis.update, \r\n\t\t\tScrollage.supportsPassive ? { passive: true } : false\r\n\t\t);\r\n\t\t(this.options.wrapper ? this.wrapper : window).addEventListener(\r\n\t\t\t'touchmove',\r\n\t\t\tthis.update,\r\n\t\t\tScrollage.supportsPassive ? { passive: true } : false\r\n\t\t);\r\n\r\n\t\t// Wrapper resize observer\r\n\t\tif (!this.resizeObserver) {\r\n\t\t\tthis.resizeObserver = new ResizeObserver(debounce(() => this.init(), 100));\r\n\t\t\tthis.resizeObserver.observe(this.wrapper);\r\n\t\t}\r\n\r\n\t\t// Update initially\r\n\t\tthis.update();\r\n\r\n\t\t// WIP >>>\r\n\t\tconsole.log(this);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Caches and initializes scroll blocks for Scrollage.\r\n\t *\r\n\t * This function iterates over the scrollage elements (`this.elems`), extracts necessary \r\n\t * data attributes, stores their original styles, determines their scroll range, \r\n\t * calculates their initial progress, and stores animation data.\r\n\t * \r\n\t * @returns {void}\r\n\t */\r\n\tcacheBlocks = () => {\r\n\t\t// Reset previously cached blocks\r\n\t\tthis.blocks = [];\r\n\r\n\t\tfor (let i = 0; i < this.elems.length; i++) {\r\n\t\t\tconst el = this.elems[i];\r\n\r\n\t\t\t// Extract scroll-related data attributes\r\n\t\t\tconst dataRangeSelector = el.getAttribute( 'data-scrollage-range' );\r\n\t\t\tconst dataOffset = el.getAttribute( 'data-scrollage-offset' );\r\n\r\n\t\t\tlet dataOffsetStart = el.getAttribute( 'data-scrollage-offset-start' );\r\n\t\t\tlet dataOffsetEnd = el.getAttribute( 'data-scrollage-offset-end' );\r\n\r\n\t\t\t// Override dataOffsetStart and dataOffsetEnd with dataOffset is specified\r\n\t\t\tif (dataOffset) {\r\n\t\t\t\t// We need to negate dataOffset before using as dataOffsetStart\r\n\t\t\t\tdataOffsetStart = dataOffset.startsWith('-') ? dataOffset.replace('-', '') : `-${dataOffset}`;\r\n\t\t\t\tdataOffsetEnd = dataOffset;\r\n\t\t\t}\r\n\r\n\t\t\t// Store original element styles\r\n\t\t\tconst originalStyles = el.style.cssText;\r\n\r\n\t\t\t// Retrieve animation data for the element\r\n\t\t\tconst animations = getAnimationData(el);\r\n\r\n\t\t\t// Validate and assign the scroll range element\r\n\t\t\tconst rangeEl = dataRangeSelector ? validateEl(dataRangeSelector, 'range') : null;\r\n\r\n\t\t\t// Get range dimensions\r\n\t\t\tconst rangeSize = { \r\n\t\t\t\tx: rangeEl?.clientWidth || this.wrapper.scrollWidth, \r\n\t\t\t\ty: rangeEl?.clientHeight || this.wrapper.scrollHeight\r\n\t\t\t};\r\n\r\n\t\t\t// Get element dimensions\r\n\t\t\tconst elSize = {\r\n\t\t\t\tx: el.clientWidth, \r\n\t\t\t\ty: el.clientHeight\r\n\t\t\t};\r\n\r\n\t\t\t// Compute scroll range and initial progress\r\n\t\t\tconst scrollRangeData = this.getScrollRange(\r\n\t\t\t\trangeEl, \r\n\t\t\t\tdataOffsetStart,\r\n\t\t\t\tdataOffsetEnd\r\n\t\t\t);\r\n\r\n\t\t\tconst progress = this.getScrollProgress(rangeEl, scrollRangeData);\r\n\r\n\t\t\t// Store the processed block\r\n\t\t\tthis.blocks.push({\r\n\t\t\t\tprogress,\r\n\t\t\t\trangeEl, // WIP >>> Need this anymore?\r\n\t\t\t\trangeSize,\r\n\t\t\t\telSize,\r\n\t\t\t\tscrollRangeData,\r\n\t\t\t\tanimations,\r\n\t\t\t\toriginalStyles\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets up and caches custom triggers in order to toggle css classes on specific scroll positions.\r\n\t *\r\n\t * This function iterates over the configured triggers, validates their properties, \r\n\t * calculates their positions relative to the viewport, and stores them for later use.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\tcacheTriggers = () => {\r\n\t\tthis.triggers = [];\r\n\r\n\t\tif (!this.options.triggers || !Array.isArray(this.options.triggers)) return;\r\n\r\n\t\tfor (let i = 0; i < this.options.triggers.length; i++) {\r\n\t\t\tconst trigger = this.options.triggers[i];\r\n\r\n\t\t\tif (trigger.range && trigger.class) {\r\n\t\t\t\tconst rangeEl = validateEl(trigger.range, 'trigger range');\r\n\t\t\t\tif (!rangeEl) continue;\r\n\r\n\t\t\t\t// WIP >>> Refactor to support vh/vw units using calculateUnitValue() >>>\r\n\r\n\t\t\t\tconst rect = rangeEl.getBoundingClientRect();\r\n\t\t\t\tconst elPos = (this.isVertical ? rect.top : rect.left) + this.getScrollPos();\r\n\t\t\t\tlet elOffset = 0,\r\n\t\t\t\t\toffsetValue = 0,\r\n\t\t\t\t\toffsetUnit = '%';\r\n\r\n\t\t\t\tif (trigger.position) {\r\n\t\t\t\t\tif (typeof trigger.position === 'string') {\r\n\t\t\t\t\t\tconst positionData = splitValueUnit(trigger.position);\r\n\t\t\t\t\t\toffsetValue = positionData?.value || 0;\r\n\t\t\t\t\t\toffsetUnit = positionData?.unit || '%';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\toffsetValue = trigger.position || 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telOffset = offsetUnit === 'px' \r\n\t\t\t\t\t\t? offsetValue \r\n\t\t\t\t\t\t: rangeEl.clientHeight * (offsetValue / 100)\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// WIP <<< Refactor to support vh/vw units using calculateUnitValue() <<<\r\n\r\n\t\t\t\tconst targetEl = ('_self' === trigger.target)\r\n\t\t\t\t\t? rangeEl\r\n\t\t\t\t\t: validateEl(trigger.target, 'trigger target') || this.wrapper;\r\n\r\n\t\t\t\tthis.triggers.push({\r\n\t\t\t\t\tposition: elPos + elOffset,\r\n\t\t\t\t\tclass: trigger.class,\r\n\t\t\t\t\ttargetEl\r\n\t\t\t\t});\r\n\t\t\t}\t\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Sets up and caches tracker elements for Scrollage.\r\n\t *\r\n\t * This function iterates over the configured trackers, validates their properties, \r\n\t * and stores them for later use. Trackers allow the tracking of specific elements \r\n\t * and their properties (e.g., CSS custom properties) based on scroll progress.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\tcacheTrackers = () => {\r\n\t\tthis.trackers = [];\r\n\r\n\t\tif (!this.options.trackers || !Array.isArray(this.options.trackers)) return;\r\n\r\n\t\tfor (let i = 0; i < this.options.trackers.length; i++) {\r\n\t\t\tconst tracker = this.options.trackers[i];\r\n\r\n\t\t\tif (tracker.selector && tracker.identifier) {\r\n\t\t\t\tconst el = validateEl(tracker.selector, 'tracker selector');\r\n\t\t\t\tif (!el) continue;\r\n\r\n\t\t\t\tif (typeof tracker.identifier !== 'string') {\r\n\t\t\t\t\tconsole.warn(\"ScrollageJS: The tracker identifier needs to be a string.\");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst targetEl = ('_self' === tracker.target) \r\n\t\t\t\t\t? el\r\n\t\t\t\t\t: validateEl(tracker.target, 'tracker target') || this.wrapper;\r\n\r\n\t\t\t\tthis.trackers.push({\r\n\t\t\t\t\tel,\r\n\t\t\t\t\tproperty: '--' + tracker.identifier,\r\n\t\t\t\t\ttargetEl\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Triggers CSS classes on elements based on scroll position.\r\n\t *\r\n\t * This function:\r\n\t * - Adds or removes a \"has-scrolled\" class on the wrapper when scrolled past a threshold.\r\n\t * - Iterates through all defined triggers and applies/removes their classes based on scroll position.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\ttriggerClasses = () => {\r\n\t\tconst scrollPos = this.getScrollPos();\r\n\r\n\t\t// Toggle the 'has-scrolled' class\r\n\t\tif (this.options.hasScrolledEnabled) {\r\n\t\t\tconst hasScrolledThreshold = this.options.hasScrolledOffset || 0;\r\n\t\t\tthis.wrapper.classList.toggle(this.options.hasScrolledClass, scrollPos > hasScrolledThreshold);\r\n\t\t}\r\n\r\n\t\t// Toggle trigger classes\r\n\t\tfor (const trigger of this.triggers) {\r\n\t\t\ttrigger.targetEl.classList.toggle(trigger.class, scrollPos >= trigger.position);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Updates tracked CSS properties based on element dimensions.\r\n\t *\r\n\t * This function:\r\n\t * - Iterates through all defined trackers.\r\n\t * - Sets a CSS custom property (`--identifier`) for each tracker, based on the element's width or height.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\ttrackProperties = () => {\r\n\t\tfor (const tracker of this.trackers) {\r\n\r\n\t\t\t// Only size for now\r\n\t\t\tconst size = this.isVertical ? tracker.el.clientHeight : tracker.el.clientWidth;\r\n\t\t\ttracker.targetEl.style.setProperty(tracker.property, `${size}px`);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Retrieves the current scroll position.\r\n\t *\r\n\t * This function returns the current scroll position of the wrapper element, \r\n\t * based on the scroll direction (vertical or horizontal).\r\n\t *\r\n\t * @returns {number} - The current scroll position in pixels.\r\n\t */\r\n\tgetScrollPos = () => {\r\n\t\treturn this.isVertical ? this.wrapper.scrollTop : this.wrapper.scrollLeft;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Calculates the scroll range (start, end, and offsets) for a given element or the wrapper.\r\n\t *\r\n\t * - If no range element is provided, it calculates based on the wrapperâ€™s scrollable dimensions.\r\n\t * - Converts `px` and `%` offsets into absolute values.\r\n\t * - Uses `getBoundingClientRect()` to determine the exact position of the range element.\r\n\t * - Outputs the computed start and end positions, including offsets, in an object.\r\n\t *\r\n\t * @param {HTMLElement|null} [rangeEl=null] - The target element defining the scroll range. Defaults to the wrapper.\r\n\t * @param {string|number} [offsetStart=0] - The start offset (e.g. `100`,`'50px'` or `'10%'`). Defaults to 0.\r\n\t * @param {string|number} [offsetEnd=0] - The end offset (e.g. `100`,`'50px'` or `'10%'`). Defaults to 0.\r\n\t * \r\n\t * @returns {Object} An object containing:\r\n\t *   @property {number} start - The start position of the scroll range.\r\n\t *   @property {number} end - The end position of the scroll range.\r\n\t *   @property {number} startOffset - The computed offset for the start position.\r\n\t *   @property {number} endOffset - The computed offset for the end position.\r\n\t *   @property {number} size - The total size of the scroll range (end - start).\r\n\t */\r\n\tgetScrollRange = (rangeEl = null, offsetStart = 0, offsetEnd = 0) => {\r\n\t\tconst offsetStartData = splitValueUnit(offsetStart);\r\n\t\tconst offsetEndData = splitValueUnit(offsetEnd);\r\n\t\tconst offsetStartValue = offsetStartData?.value || 0;\r\n\t\tconst offsetStartUnit = offsetStartData?.unit || '%';\r\n\t\tconst offsetEndValue = offsetEndData?.value || 0;\r\n\t\tconst offsetEndUnit = offsetEndData?.unit || '%';\r\n\r\n\t\tlet scrollRangeStart = 0;\r\n\t\tlet scrollRangeEnd = 0;\r\n\t\tlet scrollRangeStartOffset = 0;\r\n\t\tlet scrollRangeEndOffset = 0;\r\n\r\n\t\t// If no range specified, determine wrapper offsets...\r\n\t\tif (!rangeEl || rangeEl == this.wrapper) {\r\n\t\t\tconst contextWrapperSize = this.wrapperSize[this.isVertical ? 'y' : 'x'];\r\n\r\n\t\t\tscrollRangeEnd = contextWrapperSize;\r\n\r\n\t\t\tscrollRangeStartOffset = calculateUnitValue(offsetStartUnit, offsetStartValue, this.winSize, contextWrapperSize);\r\n\t\t\tscrollRangeEndOffset = calculateUnitValue(offsetEndUnit, offsetEndValue, this.winSize, contextWrapperSize);\r\n\r\n\t\t// ...otherwise calculate scroll range and determine range offsets\r\n\t\t} else {\r\n\t\t\tconst contextRangeSize = this.isVertical ? rangeEl.scrollHeight : rangeEl.scrollWidth;\r\n\t\t\tconst rect = rangeEl.getBoundingClientRect();\r\n        \tconst scrollPos = this.getScrollPos();\r\n\r\n\t\t\tscrollRangeStart = Math.round( ((this.isVertical ? rect.top : rect.left) + scrollPos ) * 100 ) / 100;\r\n\t\t\tscrollRangeEnd = Math.round( ((this.isVertical ? rect.bottom : rect.right) + scrollPos ) * 100 ) / 100;\r\n\r\n\t\t\tscrollRangeStartOffset = calculateUnitValue(offsetStartUnit, offsetStartValue, this.winSize, contextRangeSize);\r\n\t\t\tscrollRangeEndOffset = calculateUnitValue(offsetEndUnit, offsetEndValue, this.winSize, contextRangeSize);\r\n\t\t}\r\n\r\n\t\tconst scrollRangeSize = (scrollRangeEnd + scrollRangeEndOffset) - (scrollRangeStart + scrollRangeStartOffset);\r\n\r\n\t\treturn {\r\n\t\t\tstart: scrollRangeStart,\r\n\t\t\tend: scrollRangeEnd,\r\n\t\t\tstartOffset: scrollRangeStartOffset,\r\n\t\t\tendOffset: scrollRangeEndOffset,\r\n\t\t\tsize: scrollRangeSize\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Calculates the scroll progression as a percentage (0 to 1) within a specified scroll range.\r\n\t *\r\n\t * - Determines how far the user has scrolled relative to a given range.\r\n\t * - Can use a custom range element or default to the main wrapper.\r\n\t * - Applies offsets only when a specific range is provided.\r\n\t * - Clamps the result between 0 (not scrolled) and 1 (fully scrolled).\r\n\t *\r\n\t * @param {HTMLElement|string|null} [range=null] - The target element or selector defining the scroll range. Defaults to the wrapper.\r\n\t * @param {Object|null} [scrollRangeData=null] - Precomputed scroll range data to avoid redundant calculations.\r\n\t * \r\n\t * @returns {number} - The normalized scroll progression (0 to 1).\r\n\t */\r\n\tgetScrollProgress = (range = null, scrollRangeData = null) => {\r\n\t\tconst scrollPos = this.getScrollPos();\r\n\t\tconst contextWinSize = this.isVertical ? this.winSize.y : this.winSize.x;\r\n\t\tconst contextWrapperSize = this.isVertical ? this.wrapperSize.y : this.wrapperSize.x;\r\n\r\n\t\tconst rangeEl = range ? validateEl(range, 'range') : this.wrapper;\r\n\t\tif (!scrollRangeData) scrollRangeData = this.getScrollRange(rangeEl);\r\n\r\n\t\t// Apply range offsets\r\n\t\tconst adjustedStart = scrollRangeData.start + scrollRangeData.startOffset;\r\n\t\tconst adjustedEnd = scrollRangeData.end + scrollRangeData.endOffset;\r\n\t\t\t\r\n\t\t// Determine start and end scroll positions\r\n\t\tconst scrollStart = range \r\n\t\t\t? Math.max(0, adjustedStart - contextWinSize) - scrollPos\r\n\t\t\t: Math.max(0, adjustedStart) - scrollPos;\r\n\r\n\t\tconst scrollEnd = range \r\n\t\t\t? Math.min(contextWrapperSize - contextWinSize, adjustedEnd) - scrollPos\r\n\t\t\t: Math.min(scrollRangeData.end - contextWinSize, adjustedEnd - contextWinSize) - scrollPos;\r\n\t\t\r\n\t\t// Calculate scroll progression percentage\r\n\t\tlet scrollPercentage = scrollStart / (scrollEnd - scrollStart) * -100;\r\n\t\t\r\n\t\t// Clamp value between 0 and 100\r\n\t\tscrollPercentage = Math.min(100, Math.max(0, scrollPercentage));\r\n\t\t\r\n\t\t// Debug toggle\r\n\t\tif (false) {\r\n\t\t\tconsole.log(`scrollPos: ${scrollPos}  ||  scrollPercentage: ${scrollPercentage}`);\r\n\t\t\tconsole.log(`scrollStart: ${scrollStart}  ||  scrollEnd: ${scrollEnd}`);\r\n\t\t\tconsole.log(`scrollRangeStart: ${scrollRangeData.start}  ||  scrollRangeEnd: ${scrollRangeData.end}`);\r\n\t\t\tconsole.log(`scrollRangeStartOffset: ${scrollRangeData.startOffset}  ||  scrollRangeEndOffset: ${scrollRangeData.endOffset}`);\r\n\t\t\tconsole.log(`scrollRangeSize: ${scrollRangeData.size}  ||  contextWinSize: ${contextWinSize}`);\r\n\t\t}\r\n\r\n\t\treturn scrollPercentage / 100;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Updates the scroll progress for each cached block along with triggers and trackers.\r\n\t * \r\n\t * @returns {void} - This function does not return a value.\r\n\t */\r\n\tupdate = () => {\r\n\r\n\t\tthis.triggerClasses();\r\n\t\tthis.trackProperties();\r\n\r\n\r\n\t\tfor (let i = 0; i < this.blocks.length; i++) {\r\n\t\t\tthis.blocks[i].progress = this.getScrollProgress(\r\n\t\t\t\tthis.blocks[i].rangeEl,\r\n\t\t\t\tthis.blocks[i].scrollRangeData\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\trequestAnimationFrame(this.animate);\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Applies animations to all blocks based on their progress within the scroll range.\r\n\t * [Formula: newValue = targetMin + (targetMax - targetMin) * (sourceValue - sourceMin) / (sourceMax - sourceMin)]\r\n\t *\r\n\t * @returns {void} - This function does not return a value.\r\n\t */\r\n\tanimate = () => {\r\n\t\tfor (let i = 0; i < this.blocks.length; i++) {\r\n\t\t\tconst block = this.blocks[i];\r\n\r\n\t\t\t// Skip blocks without animations\r\n\t\t\tif (!block.animations.length) continue; \r\n\r\n\t\t\tconst breakpoint = this.currentBreakpoint;\r\n\t\t\tconst el = this.elems[i];\r\n\r\n\t\t\tlet transforms = [];\r\n\t\t\tlet filters = [];\r\n\t\t\tlet opacityValue = null;\r\n\t\r\n\t\t\tfor (let j = 0; j < block.animations.length; j++) {\r\n\t\t\t\tconst animation = block.animations[j];\r\n\t\r\n\t\t\t\tif (animation.move) {\r\n\t\t\t\t\ttransforms.push( \r\n\t\t\t\t\t\tmove(animation.move.responsive?.[breakpoint] || animation.move, block.progress, block.rangeSize, block.elSize, this.winSize) \r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (animation.rotate) {\r\n\t\t\t\t\ttransforms.push( \r\n\t\t\t\t\t\trotate(animation.rotate.responsive?.[breakpoint] || animation.rotate, block.progress) \r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (animation.scale) {\r\n\t\t\t\t\ttransforms.push( \r\n\t\t\t\t\t\tscale(animation.scale.responsive?.[breakpoint] || animation.scale, block.progress) \r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (animation.saturate) {\r\n\t\t\t\t\tfilters.push( \r\n\t\t\t\t\t\tsaturate(animation.saturate.responsive?.[breakpoint] || animation.saturate, block.progress) \r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (animation.blur) {\r\n\t\t\t\t\tfilters.push( \r\n\t\t\t\t\t\tblur(animation.blur.responsive?.[breakpoint] || animation.blur, block.progress) \r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (animation.fade) {\r\n\t\t\t\t\topacityValue = fade(animation.fade.responsive?.[breakpoint] || animation.fade, block.progress);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (transforms.length) el.style.transform = transforms.join(' ');\r\n\t\t\tif (filters.length) el.style.filter = filters.join(' ');\r\n\t\t\tif (opacityValue) el.style.opacity = opacityValue;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Cleans up and resets all ScrollageJS elements, event listeners, and animations.\r\n\t *\r\n\t * - Restores original element styles.\r\n\t * - Removes trigger classes from target elements.\r\n\t * - Resets tracked CSS variables.\r\n\t * - Detaches all event listeners.\r\n\t */\r\n\tdestroy = () => {\r\n\t\t// Reset element styles\r\n\t\tfor (let i = 0; i < this.elems.length; i++) {\r\n\t\t\tthis.elems[i].style.cssText = this.blocks[i]?.originalStyles || '';\r\n\t\t}\r\n\t\tthis.elems = [];\r\n\t\tthis.blocks = [];\r\n\t\t\r\n\t\t// Reset trigger classes\r\n\t\tfor (let i = 0; i < this.triggers.length; i++) {\r\n\t\t\tthis.triggers[i].targetEl.classList.remove(this.triggers[i]?.class);\r\n\t\t}\r\n\t\tthis.triggers = [];\r\n\t\t\r\n\t\t// Reset tracker properties\r\n\t\tfor (let i = 0; i < this.trackers.length; i++) {\r\n\t\t\tthis.trackers[i].targetEl.style.removeProperty(this.trackers[i]?.property);\r\n\t\t}\r\n\t\tthis.trackers = [];\r\n\t\t\r\n\t\t// Remove event listeners\r\n\t\t(this.options.wrapper ? this.wrapper : window).removeEventListener('scroll', this.update);\r\n\t\t(this.options.wrapper ? this.wrapper : window).removeEventListener('touchmove', this.update);\r\n\t\twindow.removeEventListener('resize', debounce(this.init.bind(this)));\r\n\t\twindow.removeEventListener('orientationchange', debounce(this.init.bind(this)));\r\n\t}\r\n\r\n}\r\n\r\n// Expose Scrollage globally for browsers\r\nif (typeof window !== 'undefined') {\r\n    window.Scrollage = Scrollage;\r\n}"],"names":[],"sourceRoot":""}